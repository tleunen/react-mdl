import React, { PropTypes } from 'react';
import { findDOMNode } from 'react-dom';
import classNames from 'classnames';

// Ripple effect taken from https://github.com/google/material-design-lite/blob/master/src/ripple/ripple.js
const INITIAL_SCALE = 'scale(0.0001, 0.0001)';
const FINAL_SCALE = '';

const propTypes = {
    ripple: PropTypes.bool
};

export default (Component, options = {}) => {
    const { prefix, center } = options;

    class Ripple extends React.Component {
        constructor(props) {
            super(props);
            this.blurComponent = this.blurComponent.bind(this);
            this.animFrameHandler = this.animFrameHandler.bind(this);
            this.handleDown = this.handleDown.bind(this);
            this.handleUp = this.handleUp.bind(this);

            this.frameCount = 0;
            this.x = 0;
            this.y = 0;

            // Touch start produces a compat mouse down event, which would cause a
            // second ripples. To avoid that, we use this property to ignore the first
            // mouse down after a touch start.
            this.ignoringMouseDown = false;

            this.state = {
                rippleSize: 0,
                rippleVisible: false,
                rippleAnimating: false,
                rippleTransform: ''
            };
        }

        setRippleStyles(start) {
            if (this.props.ripple) {
                const scale = start ? INITIAL_SCALE : FINAL_SCALE;
                const offset = !start && center
                    ? `translate(${this.boundWidth / 2}px, ${this.boundHeight / 2}px)`
                    : `translate(${this.x}px, ${this.y}px)`;

                this.setState({
                    rippleAnimating: !start,
                    rippleTransform: `translate(-50%, -50%) ${offset} ${scale}`
                });
            }
        }

        animFrameHandler() {
            if (!this.props.ripple) return;

            if (this.frameCount-- > 0) {
                requestAnimationFrame(this.animFrameHandler);
            } else {
                this.setRippleStyles(false);
            }
        }

        blurComponent(event) {
            if (event) {
                findDOMNode(this).blur();
            }

            if (this.props.ripple) {
                this.handleUp(event);
            }
        }

        handleDown(event) {
            if (!this.props.ripple) return;

            const element = findDOMNode(this);

            const rect = element.getBoundingClientRect();
            this.boundHeight = rect.height;
            this.boundWidth = rect.width;
            const rippleSize = Math.sqrt(rect.width * rect.width +
                rect.height * rect.height) * 2 + 2;

            this.setState({
                rippleSize,
                rippleVisible: true
            });
            // this.rippleElement_.style.width = this.rippleSize_ + 'px';
            // this.rippleElement_.style.height = this.rippleSize_ + 'px';

            if (event.type === 'mousedown' && this.ignoringMouseDown_) {
                this.ignoringMouseDown = false;
            } else {
                if (event.type === 'touchstart') {
                    this.ignoringMouseDown = true;
                }

                if (this.frameCount > 0) {
                    return;
                }

                this.frameCount = 1;
                const bound = event.currentTarget.getBoundingClientRect();
                // Check if we are handling a keyboard click.
                if (event.clientX === 0 && event.clientY === 0) {
                    this.x = Math.round(bound.width / 2);
                    this.y = Math.round(bound.height / 2);
                } else {
                    const clientX = event.clientX ? event.clientX : event.touches[0].clientX;
                    const clientY = event.clientY ? event.clientY : event.touches[0].clientY;
                    this.x = Math.round(clientX - bound.left);
                    this.y = Math.round(clientY - bound.top);
                }

                this.setRippleStyles(true);
                requestAnimationFrame(this.animFrameHandler);
            }
        }

        handleUp() {
            if (!this.props.ripple) return;

            // Don't fire for the artificial "mouseup" generated by a double-click.
            if (event && event.detail !== 2) {
                this.setState({
                    rippleVisible: false
                });
            }
        }

        render() {
            const { children, ripple, ...otherProps } = this.props;
            const { rippleSize, rippleVisible,
                rippleAnimating, rippleTransform } = this.state;

            if (!ripple) {
                return (
                    <Component
                        onMouseUp={this.blurComponent}
                        onMouseLeave={this.blurComponent}
                        {...otherProps}
                    >
                        {children}
                    </Component>
                );
            }

            const rippleStyles = {
                width: `${rippleSize}px`,
                height: `${rippleSize}px`,
                transform: rippleTransform,
                WebkitTransform: rippleTransform,
                MsTransform: rippleTransform
            };
            const rippleClasses = classNames('mdl-ripple', {
                'is-visible': rippleVisible,
                'is-animating': rippleAnimating
            });

            return (
                <Component
                    {...otherProps}
                    onMouseUp={this.blurComponent}
                    onMouseLeave={this.blurComponent}
                    onMouseDown={this.handleDown}
                    onTouchStart={this.handleDown}
                    onTouchEnd={this.handleUp}
                    onBlur={this.handleUp}
                >
                    {children}
                    <span className={`${prefix}__ripple-container`}>
                        <span
                            className={rippleClasses}
                            onMouseUp={this.blurComponent}
                            style={rippleStyles}
                        />
                    </span>
                </Component>
            );
        }
    }

    Ripple.propTypes = propTypes;
    return Ripple;
};
